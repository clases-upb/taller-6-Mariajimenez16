/*
 * This source file was generated by the Gradle 'init' task
 */
package org.example;
import java.util.Random;
import java.util.Scanner;
import java.util.Arrays;
import java.io.BufferedReader;

public class App {
    static int[] numeros;
    static String[] cadenas;
    static String [] palabras;

    public static void main(String[] args) {
        
        try {
             // Inicializar vectores
        numeros = new int[10]; 
        cadenas = new String[10]; 
        palabras = new String[10]; 
        
        int opcion;
            switch (opcion) {
                case 1:
                    pruebaVectores();
                    break;
                case 2:
                    pruebaMatrizTranspuesta();
                    break;
                case 3:
                    pruebaProductoDivisionDiagonales();
                    break;
                case 4:
                    pruebaLlenarMatrizXsOs();
                    break;
                case 5:
                    pruebaContarRepetidosMatriz();
                    break;
                default:
                    System.out.println("Opción no válida.");
            }

        } catch (Exception e) {
            System.out.println("ocurrio un error \n" + e.toString());
        }
    }

    /*
     * 1. Implemente un programa en java donde inserte elementos en dos vectores
     * globales de tamaños aleatorios y de contenido aleatorio (uno numérico y otro
     * de Strings). Considere dejar espacios libres en los vectores.
     * 
     * Desde un menú en el programa principal debe considerar cada opción para
     * llamar las siguientes funciones que también debe programar:
     * 
     * a. Recorrer secuencialmente (recibe un true cuando va del primero al último y
     * un false cuando va del último al primero)
     * • De primer elemento a último elemento: Imprime desde el primer elemento
     * hasta el último del vector dado en el parámetro de entrada.
     * • De último elemento al primer elemento: Imprime desde el último elemento
     * hasta el primero del vector dado en el parámetro de entrada.
     * 
     * b. Actualizar: recibe la posición que va a actualizar y el elemento. Al final
     * imprime el vector actualizado.
     * 
     * c. Añadir: después del último: recibe el elemento que va a añadir. Al final
     * imprime el vector actualizado.
     * 
     * d. Borrar: Recibe la posición donde del elemento que va a borrar.
     * 
     * e. Ordenar el vector:
     * • Ascendentemente.
     * • Descendentemente.
     * 
     * f. Búsqueda: Recibe como parámetro el elemento a buscar y devuelve un String
     * separado por el carácter '-', mostrando las posiciones donde se encuentra el
     * elemento.
     */

        // a. Recorrer secuencialmente
    public static void recorrerVectorNumerico(boolean forward) {
        try {
            if (forward) {
                for (int i = 0; i < numeros.length; i++) {
                    System.out.print(numeros[i] + " ");
                }
            } else {
                for (int i = numeros.length - 1; i >= 0; i--) {
                    System.out.print(numeros[i] + " ");
                }
            }
            System.out.println();
        } catch (Exception e) {
            System.out.println("Error al recorrer vector: " + e.getMessage());
        }
    }

    public static void recorrerVectorCadenas(boolean forward) {
        try {
            if (forward) {
                for (int i = 0; i < cadenas.length; i++) {
                    System.out.print(cadenas[i] + " ");
                }
            } else {
                for (int i = cadenas.length - 1; i >= 0; i--) {
                    System.out.print(cadenas[i] + " ");
                }
            }
            System.out.println();
        } catch (Exception e) {
            System.out.println("Error al recorrer vector: " + e.getMessage());
        }
    }

    // b. Actualizar
    public static void actualizarNumerico(int pos, int valor) {
        try {
            numeros[pos] = valor;
            System.out.println("Vector actualizado:");
            recorrerVectorNumerico(true);
        } catch (ArrayIndexOutOfBoundsException e) {
            System.out.println("Error: Posición fuera de rango.");
        }
    }

    // c. Añadir
    public static void añadirCadena(String elemento) {
        try {
            for (int i = 0; i < cadenas.length; i++) {
                if (cadenas[i] == null) {
                    cadenas[i] = elemento;
                    break;
                }
            }
            System.out.println("Vector actualizado:");
            recorrerVectorCadenas(true);
        } catch (Exception e) {
            System.out.println("Error al añadir: " + e.getMessage());
        }
    }

    // d. Borrar
    public static void borrarNumerico(int pos) {
        try {
            numeros[pos] = 0; // Dejar en 0
            System.out.println("Vector después de borrar:");
            recorrerVectorNumerico(true);
        } catch (ArrayIndexOutOfBoundsException e) {
            System.out.println("Error: Posición fuera de rango.");
        }
    }

    // e. Ordenar el vector
    public static void ordenarNumerico() {
        try {
            Arrays.sort(numeros);
            System.out.println("Vector ordenado ascendentemente:");
            recorrerVectorNumerico(true);
        } catch (Exception e) {
            System.out.println("Error al ordenar: " + e.getMessage());
        }
    }

    // f. Búsqueda
    public static void buscarCadena(String elemento) {
        try {
            StringBuilder posiciones = new StringBuilder();
            for (int i = 0; i < cadenas.length; i++) {
                if (cadenas[i] != null && cadenas[i].equals(elemento)) {
                    posiciones.append(i).append("-");
                }
            }
            if (posiciones.length() > 0) {
                System.out.println("Elemento encontrado en posiciones: " + posiciones);
            } else {
                System.out.println("Elemento no encontrado.");
            }
        } catch (Exception e) {
            System.out.println("Error en la búsqueda: " + e.getMessage());
        }
    }
}

    /*
     * 2. Escriba un algoritmo que calcule aleatoriamente N temperaturas, las lleve
     * a un vector y luego calcule su media, cuántas temperaturas están por encima
     * de la media y cuántas por debajo.
     */
    public static void calcularTemperaturas() {
        try {
            Scanner scanner = new Scanner(System.in);
            System.out.print("¿Cuántas temperaturas deseas generar? ");
            int n = scanner.nextInt();
            double[] temperaturas = new double[n];
            Random random = new Random();

            for (int i = 0; i < n; i++) {
                temperaturas[i] = random.nextDouble() * 40; 
            }

            double suma = 0;
            for (double temp : temperaturas) {
                suma += temp;
            }
            double media = suma / n;

            int encimaMedia = 0, debajoMedia = 0;
            for (double temp : temperaturas) {
                if (temp > media) encimaMedia++;
                else if (temp < media) debajoMedia++;
            }

            System.out.println("Temperaturas generadas: " + Arrays.toString(temperaturas));
            System.out.println("Media: " + media);
            System.out.println("Temperaturas por encima de la media: " + encimaMedia);
            System.out.println("Temperaturas por debajo de la media: " + debajoMedia);

        } catch (Exception e) {
            System.out.println("Error en calcularTemperaturas: " + e.getMessage());
        }
    }

    /*
     * 3. Cargue un vector a partir de un archivo de palabras, con mínimo 10
     * palabras. Ordene el vector de manera ascendente y luego de forma descendente.
     * 
     * Escriba el vector inicial sin ordenar, los vectores ordenados.
     */
     public static void cargarPalabras(String nombreArchivo) {
        try (BufferedReader reader = new BufferedReader(new FileReader(nombreArchivo))) {
            palabras = new String[10]; 
            String linea;
            int index = 0;

            while ((linea = reader.readLine()) != null && index < palabras.length) {
                palabras[index++] = linea.trim();
            }
        } catch (IOException e) {
            System.out.println("Error al leer el archivo: " + e.getMessage());
        } catch (Exception e) {
            System.out.println("Error inesperado: " + e.getMessage());
        }
    }

    /*
     * 4. Escriba un algoritmo que cree un vector de N elementos (el N es dado por
     * el usuario) de números short aleatorios positivos mayores que cero, y luego
     * le pregunte al usuario qué posición quiere eliminar. Luego por un menú
     * presente las opciones: Dejar la casilla en 0 o desplazar los elementos de
     * manera que el cero quede en la última posición del vector. Después de la
     * operación mostrará el vector cómo va quedando y volverá a preguntar qué
     * posición quiere borrar y mostrará nuevamente el menú. En el menú aparecerá la
     * opción para terminar el programa.
     */

        public static void llenarVector(short[] vector) {
        Random random = new Random();
        try {
            for (int i = 0; i < vector.length; i++) {
                vector[i] = (short) (random.nextInt(Short.MAX_VALUE) + 1); 
            }
        } catch (Exception e) {
            System.out.println("Error al llenar el vector: " + e.getMessage());
        }
    }

    public static void imprimirVector(short[] vector) {
        for (short elemento : vector) {
            System.out.print(elemento + " ");
        }
        System.out.println();
    }

    public static void desplazarElementos(short[] vector, int posicion) {
        try {
            for (int i = posicion; i < vector.length - 1; i++) {
                vector[i] = vector[i + 1]; 
            }
            vector[vector.length - 1] = 0; 
        } catch (Exception e) {
            System.out.println("Error al desplazar los elementos: " + e.getMessage());
        }
    }

    /*
     * 5. Escriba un algoritmo para convertir un número decimal en un número
     * hexadecimal, apoyado en vectores.
     */
    public static String convertirDecimalHexadecimal(int decimal) {
        String hex = "";
        char[] digitosHex = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};
        
        try {
            if (decimal == 0) {
                return "0"; 
            }
            
            while (decimal > 0) {
                int residuo = decimal % 16; 
                hex = digitosHex[residuo] + hex; 
                decimal = decimal / 16; 
            }
    
        } catch (Exception e) {
            System.out.println("Error al convertir a hexadecimal: " + e.getMessage());
        }
        
        return hex; 
    }

    /*
     * 6. Escriba un algoritmo que solicite al usuario el orden de una matriz
     * cuadrática, implemente su matriz transpuesta (investiga qué es) y la imprima.
     */
     public static void llenarMatriz(int[][] matriz) {
        Scanner scanner = new Scanner(System.in);
        try {
            for (int i = 0; i < matriz.length; i++) {
                for (int j = 0; j < matriz[i].length; j++) {
                    System.out.print("Ingrese el elemento [" + i + "][" + j + "]: ");
                    matriz[i][j] = scanner.nextInt();
                }
            }
        } catch (Exception e) {
            System.out.println("Error al ingresar datos: " + e.getMessage());
        }
    }

    public static int[][] calcularTranspuesta(int[][] matriz) {
        int n = matriz.length;
        int[][] transpuesta = new int[n][n];
        
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                transpuesta[j][i] = matriz[i][j];
            }
        }
        
        return transpuesta;
    }

    /*
     * 7. Escriba un algoritmo que calcule el producto y la división. Los operandos
     * serán la suma de elementos de la diagonal principal y la suma de los
     * elementos de la diagonal secundaria. Los elementos de la matriz deben ser
     * llenados usando la función random para calcular números aleatorios entre 10 y
     * 100.
     */
     public static void completarmatriz(int[][] matriz) {
        Random random = new Random();
        try {
            for (int i = 0; i < matriz.length; i++) {
                for (int j = 0; j < matriz[i].length; j++) {
                    matriz[i][j] = random.nextInt(91) + 10; 
                }
            }
        } catch (Exception e) {
            System.out.println("Error al llenar la matriz: " + e.getMessage());
        }
    }

    public static int calcularSumaDiagonalPrincipal(int[][] matriz) {
        int suma = 0;
        try {
            for (int i = 0; i < matriz.length; i++) {
                suma += matriz[i][i]; 
            }
        } catch (Exception e) {
            System.out.println("Error al calcular la suma de la diagonal principal: " + e.getMessage());
        }
        return suma;
    }

    public static int calcularSumaDiagonalSecundaria(int[][] matriz) {
        int suma = 0;
        try {
            for (int i = 0; i < matriz.length; i++) {
                suma += matriz[i][matriz.length - 1 - i]; 
            }
        } catch (Exception e) {
            System.out.println("Error al calcular la suma de la diagonal secundaria: " + e.getMessage());
        }
        return suma;
    }

    /*
     * 8. Escriba un algoritmo que llene de manera aleatoria una matriz de 100 filas
     * por 3 columnas con Xs y Os. Y mediante un vector cuente el número de Xs y Os
     * en cada fila. Imprima la matriz antes de llenarla, luego de llenarla y el
     * vector con el resultado.
     */
    public static void llenarMatriz(char[][] matriz, int[][] conteo) {
        Random random = new Random();
        try {
            for (int i = 0; i < matriz.length; i++) {
                for (int j = 0; j < matriz[i].length; j++) {
                    
                    matriz[i][j] = random.nextBoolean() ? 'X' : 'O';
                    
                    if (matriz[i][j] == 'X') {
                        conteo[i][0]++; 
                    } else {
                        conteo[i][1]++; 
                    }
                }
            }
        } catch (Exception e) {
            System.out.println("Error al llenar la matriz: " + e.getMessage());
        }
    }


    /*
     * 9. Llene una matriz de 5x5 con números aleatorios entre 1 y 9. En un vector
     * adicional, calcule la cantidad de números repetidos por cada fila y en otro
     * vector la cantidad de números repetidos de cada columna.
     */
         public static void Matriz(int[][] matriz) {
        Random random = new Random();
        try {
            for (int i = 0; i < matriz.length; i++) {
                for (int j = 0; j < matriz[i].length; j++) {
                    matriz[i][j] = random.nextInt(9) + 1; 
                }
            }
        } catch (Exception e) {
            System.out.println("Error al llenar la matriz: " + e.getMessage());
        }
    }

    public static int contarRepetidos(int[] fila) {
        int repetidos = 0;
        boolean[] contados = new boolean[10]; 
        try {
            for (int i = 0; i < fila.length; i++) {
                if (fila[i] >= 1 && fila[i] <= 9 && !contados[fila[i]]) {
                    
                    int count = 0;
                    for (int j = 0; j < fila.length; j++) {
                        if (fila[i] == fila[j]) {
                            count++;
                        }
                    }
                    if (count > 1) {
                        repetidos += count - 1; 
                    }
                    contados[fila[i]] = true;
                }
            }
        } catch (Exception e) {
            System.out.println("Error al contar repetidos en la fila: " + e.getMessage());
        }
        return repetidos;
    }

    public static int contarRepetidosPorColumna(int[][] matriz, int columna) {
        int repetidos = 0;
        boolean[] contados = new boolean[10]; 
        try {
            for (int i = 0; i < matriz.length; i++) {
                int numero = matriz[i][columna];
                if (numero >= 1 && numero <= 9 && !contados[numero]) {
               
                    int count = 0;
                    for (int j = 0; j < matriz.length; j++) {
                        if (numero == matriz[j][columna]) {
                            count++;
                        }
                    }
                    if (count > 1) {
                        repetidos += count - 1; 
                    }
                    contados[numero] = true; 
                }
            }
        } catch (Exception e) {
            System.out.println("Error al contar repetidos en la columna: " + e.getMessage());
        }
        return repetidos;
    }

}
